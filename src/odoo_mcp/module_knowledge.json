{
  "_description": "Module-specific methods and patterns for Odoo 19+",
  "_version": "1.4.0",
  "_updated": "2026-01-28",
  "_validated_against": "Odoo 19.0 source code and official documentation",

  "model_limitations": {
    "_note": "Known model-specific limitations and workarounds for the JSON-2 API. This list is enriched automatically when 500 errors trigger the fallback mechanism.",
    "stock.move.line": {
      "search_read": {
        "status": "unstable",
        "error": "500 Internal Server Error",
        "workaround": "Use search() + read() separately (automatic fallback enabled)",
        "verified": true,
        "root_causes": {
          "picking_type_id_search": {
            "description": "picking_type_id is a computed field with custom search that returns NotImplemented for negative operators",
            "affected_operators": ["!=", "not in", "not like"],
            "solution": "Avoid filtering on picking_type_id with negative operators. Use picking_id.picking_type_id instead."
          },
          "deep_related_fields": {
            "description": "Several related fields create 3+ level JOINs that may timeout or fail",
            "problematic_fields": ["product_category_name", "picking_code", "picking_partner_id", "move_partner_id"],
            "solution": "Exclude these fields from 'fields' parameter, fetch separately if needed"
          },
          "non_stored_computed": {
            "description": "Fields like lots_visible and allowed_uom_ids are computed but not stored",
            "problematic_fields": ["lots_visible", "allowed_uom_ids"],
            "solution": "Exclude from 'fields' parameter - they must be computed per-record"
          }
        },
        "safe_fields": ["id", "product_id", "lot_id", "quantity", "location_id", "location_dest_id", "picking_id", "move_id", "state", "date"],
        "avoid_in_domain": ["picking_type_id with !=", "product_category_name", "any 3+ level dot notation"],
        "avoid_in_fields": ["lots_visible", "allowed_uom_ids", "picking_code", "product_category_name"]
      }
    }
  },

  "json2_api": {
    "_note": "Official Odoo 19 JSON-2 API specification (from odoo.com/documentation/19.0)",
    "endpoint": "/json/2/{model}/{method}",
    "method": "POST",
    "headers": {
      "Authorization": {
        "format": "Bearer {api_key}",
        "required": true,
        "description": "API key generated per user in Odoo settings"
      },
      "Content-Type": {
        "value": "application/json",
        "required": true
      },
      "X-Odoo-Database": {
        "required": "optional (required for multi-db)",
        "description": "Target database name"
      }
    },
    "request_format": {
      "description": "JSON object with named parameters only (no positional args)",
      "example": {
        "domain": [["is_company", "=", true]],
        "fields": ["name", "email"],
        "limit": 10
      }
    },
    "transaction": {
      "description": "Each API call runs in its own SQL transaction",
      "commit": "On success",
      "rollback": "On error",
      "note": "Cannot chain multiple calls in single transaction"
    },
    "deprecation_notice": {
      "deprecated": ["/xmlrpc", "/xmlrpc/2", "/jsonrpc"],
      "removal": "Odoo 20 (fall 2026)",
      "replacement": "JSON-2 API at /json/2/"
    },
    "documentation_endpoint": {
      "url": "/doc",
      "description": "Built-in API documentation for every Odoo 19 instance",
      "features": ["Browse all models", "View fields and methods", "Generate code snippets (Python, JSON, etc.)"]
    }
  },

  "domain_syntax": {
    "_note": "Complete domain operator reference for Odoo 19 JSON-2 API",
    "operators": {
      "comparison": {
        "=": {"description": "Equals", "example": ["name", "=", "John"]},
        "!=": {"description": "Not equals", "example": ["state", "!=", "draft"]},
        ">": {"description": "Greater than", "example": ["amount", ">", 1000]},
        ">=": {"description": "Greater than or equal", "example": ["date", ">=", "2024-01-01"]},
        "<": {"description": "Less than", "example": ["quantity", "<", 10]},
        "<=": {"description": "Less than or equal", "example": ["priority", "<=", 2]},
        "=?": {"description": "Equals if value is set, otherwise True (conditional)", "example": ["partner_id", "=?", false], "note": "Useful for optional filters"}
      },
      "list": {
        "in": {"description": "Value in list", "example": ["state", "in", ["draft", "sent"]]},
        "not in": {"description": "Value not in list", "example": ["state", "not in", ["cancel", "done"]]}
      },
      "text": {
        "like": {"description": "Pattern match (case-sensitive, auto-adds %wildcards%)", "example": ["name", "like", "test"]},
        "ilike": {"description": "Pattern match (case-insensitive, auto-adds %wildcards%)", "example": ["email", "ilike", "@gmail"]},
        "=like": {"description": "Exact pattern match (case-sensitive, manual wildcards)", "example": ["code", "=like", "SO%"]},
        "=ilike": {"description": "Exact pattern match (case-insensitive, manual wildcards)", "example": ["name", "=ilike", "john%"]},
        "not like": {"description": "Negated like", "example": ["name", "not like", "test"]},
        "not ilike": {"description": "Negated ilike", "example": ["email", "not ilike", "spam"]},
        "not =like": {"description": "Negated exact pattern (v17+)", "example": ["zip", "not =like", "75%"]},
        "not =ilike": {"description": "Negated exact pattern case-insensitive (v17+)", "example": ["city", "not =ilike", "paris%"]}
      },
      "hierarchical": {
        "child_of": {"description": "Record is child/grandchild of given ID (uses _parent_name)", "example": ["category_id", "child_of", 5], "note": "Works on models with parent_id or _parent_name field"},
        "parent_of": {"description": "Record is parent/grandparent of given ID", "example": ["id", "parent_of", 10], "note": "Inverse of child_of"}
      },
      "relational": {
        "any": {"description": "At least one related record matches (x2many)", "example": ["order_line", "any", [["product_id", "=", 1]]], "note": "v17+ for One2many/Many2many"},
        "not any": {"description": "No related record matches", "example": ["invoice_ids", "not any", [["state", "=", "posted"]]]}
      },
      "logic": {
        "&": {"description": "AND (default, implicit between terms)", "example": ["&", ["state", "=", "draft"], ["amount", ">", 100]]},
        "|": {"description": "OR", "example": ["|", ["state", "=", "draft"], ["state", "=", "sent"]]},
        "!": {"description": "NOT (negates following term)", "example": ["!", ["active", "=", false]]}
      }
    },
    "dot_notation": {
      "_note": "Access related fields with dot notation",
      "examples": [
        {"domain": ["partner_id.country_id.code", "=", "US"], "description": "Filter by related country code"},
        {"domain": ["order_id.partner_id.is_company", "=", true], "description": "Filter by customer type via order"}
      ]
    },
    "complex_examples": [
      {
        "description": "Active customers in US or Canada with orders > $1000",
        "domain": ["&", "&", ["active", "=", true], ["is_company", "=", true], "|", ["country_id.code", "=", "US"], ["country_id.code", "=", "CA"]]
      },
      {
        "description": "Invoices from last 30 days that are unpaid",
        "domain": ["&", ["move_type", "=", "out_invoice"], "&", ["invoice_date", ">=", "2024-12-01"], ["payment_state", "in", ["not_paid", "partial"]]]
      },
      {
        "description": "Products in category or any child category",
        "domain": ["categ_id", "child_of", 1]
      },
      {
        "description": "Orders with at least one line containing product X",
        "domain": ["order_line", "any", [["product_id", "=", 42]]]
      }
    ]
  },

  "pagination": {
    "_note": "How to paginate results with execute_method",
    "parameters": {
      "limit": {"type": "integer", "default": 100, "max": 1000, "description": "Maximum records to return"},
      "offset": {"type": "integer", "default": 0, "description": "Number of records to skip"},
      "order": {"type": "string", "example": "create_date desc, name asc", "description": "Sort order (field [asc|desc], ...)"}
    },
    "get_total_count": {
      "description": "Use search_count before paginating to know total",
      "example": {
        "step1": "execute_method('res.partner', 'search_count', args_json='[[\"is_company\", \"=\", true]]')",
        "step2": "execute_method('res.partner', 'search_read', kwargs_json='{\"domain\": [[\"is_company\", \"=\", true]], \"limit\": 50, \"offset\": 0}')"
      }
    },
    "iterate_all": {
      "description": "Pattern to fetch all records in batches",
      "pattern": "Loop: offset=0, limit=100, then offset+=limit until result count < limit"
    }
  },

  "hierarchical_models": {
    "_note": "Models with parent/child tree structure",
    "common_models": {
      "product.category": {"parent_field": "parent_id", "has_parent_store": true},
      "account.account": {"parent_field": "parent_id", "has_parent_store": true},
      "hr.department": {"parent_field": "parent_id", "has_parent_store": true},
      "stock.location": {"parent_field": "location_id", "has_parent_store": true},
      "documents.folder": {"parent_field": "parent_folder_id", "has_parent_store": true},
      "project.task": {"parent_field": "parent_id", "has_parent_store": false},
      "knowledge.article": {"parent_field": "parent_id", "has_parent_store": true}
    },
    "query_patterns": {
      "get_all_children": {
        "description": "Get record and all descendants",
        "example": "search_read with domain [['id', 'child_of', parent_id]]"
      },
      "get_all_parents": {
        "description": "Get record and all ancestors",
        "example": "search_read with domain [['id', 'parent_of', child_id]]"
      },
      "get_direct_children": {
        "description": "Get only immediate children",
        "example": "search_read with domain [['parent_id', '=', parent_id]]"
      },
      "get_root_records": {
        "description": "Get records with no parent",
        "example": "search_read with domain [['parent_id', '=', false]]"
      },
      "get_tree_path": {
        "description": "Use parent_path field if _parent_store=True",
        "example": "Read parent_path field, split by '/' to get ancestor IDs"
      }
    }
  },

  "aggregation": {
    "_note": "Aggregation reference: read_group (deprecated) and formatted_read_group (v19+ recommended)",
    "read_group": {
      "status": "deprecated in v19 - still works for backward compatibility",
      "method": "read_group",
      "parameters": {
        "domain": "Filter records before grouping",
        "fields": "List of field:aggregator specs",
        "groupby": "Fields to group by (supports :day, :week, :month, :quarter, :year for dates)",
        "offset": "Skip N groups",
        "limit": "Max groups to return",
        "order": "Sort order (renamed from orderby in v19)",
        "lazy": {
          "type": "boolean",
          "default": true,
          "description": "If True (default), groups by first groupby field only; remaining fields are lazy-loaded in subsequent queries. If False, performs all groupings in a single query - more efficient for multiple groupby fields."
        }
      },
      "examples": [
        {
          "description": "Total sales by customer",
          "call": "read_group(domain=[], fields=['amount_total:sum'], groupby=['partner_id'])"
        },
        {
          "description": "Invoice count by month",
          "call": "read_group(domain=[['move_type','=','out_invoice']], fields=['__count'], groupby=['invoice_date:month'])"
        }
      ]
    },
    "formatted_read_group": {
      "status": "v19+ recommended replacement for read_group",
      "method": "formatted_read_group",
      "module": "web (available when web module installed, i.e. always in standard Odoo)",
      "parameters": {
        "domain": "Filter records before grouping",
        "groupby": "Fields to group by (supports :day, :week, :month, :quarter, :year for dates)",
        "aggregates": "List of 'field:agg' specs (e.g. 'amount_total:sum', '__count')",
        "having": "Filter on aggregated values (list of conditions)",
        "offset": "Skip N groups",
        "limit": "Max groups to return",
        "order": "Sort order"
      },
      "note": "Key difference: uses 'aggregates' parameter instead of 'fields'. No 'lazy' parameter - always returns all grouping levels.",
      "examples": [
        {
          "description": "Total sales by customer",
          "call": "formatted_read_group(domain=[], groupby=['partner_id'], aggregates=['amount_total:sum'])"
        },
        {
          "description": "Invoice count by month",
          "call": "formatted_read_group(domain=[['move_type','=','out_invoice']], groupby=['invoice_date:month'], aggregates=['__count'])"
        },
        {
          "description": "Average order value by salesperson",
          "call": "formatted_read_group(domain=[], groupby=['user_id'], aggregates=['amount_total:avg'])"
        }
      ]
    },
    "aggregators": {
      "__count": "Count records in group",
      "sum": "Sum of field values",
      "avg": "Average of field values",
      "min": "Minimum value",
      "max": "Maximum value",
      "count_distinct": "Count distinct values",
      "array_agg": "Collect values into array"
    },
    "migration_guide": {
      "description": "Migrating from read_group to formatted_read_group",
      "old": "read_group(domain=[], fields=['amount_total:sum'], groupby=['partner_id'])",
      "new": "formatted_read_group(domain=[], groupby=['partner_id'], aggregates=['amount_total:sum'])",
      "changes": [
        "'fields' parameter renamed to 'aggregates'",
        "'aggregates' comes after 'groupby' (different arg order)",
        "No 'lazy' parameter - all groupings returned in single query",
        "New 'having' parameter for filtering on aggregated values"
      ]
    }
  },

  "orm_methods": {
    "_note": "Detailed ORM method reference for Odoo 19",
    "search": {
      "signature": "Model.search(domain, offset=0, limit=None, order=None, count=False)",
      "description": "Search for record IDs matching domain criteria",
      "parameters": {
        "domain": {"type": "list", "description": "Filter conditions as list of tuples/operators"},
        "offset": {"type": "int", "default": "0", "description": "Number of records to skip"},
        "limit": {"type": "int | None", "default": "None", "description": "Maximum records to return (None = all)"},
        "order": {"type": "str | None", "default": "None", "description": "Sort order (e.g., 'name asc, id desc')"},
        "count": {"type": "bool", "default": "False", "description": "If True, return count instead of recordset"}
      },
      "returns": "Recordset of matching records (or int if count=True)",
      "vs_search_read": "search() returns only IDs; use search_read() when you need field values too",
      "examples": [
        {
          "description": "Search active partners",
          "call": "execute_method('res.partner', 'search', kwargs_json='{\"domain\": [[\"active\", \"=\", true]], \"limit\": 100}')"
        },
        {
          "description": "Search with OR condition",
          "call": "execute_method('res.partner', 'search', kwargs_json='{\"domain\": [\"|\", [\"is_company\", \"=\", true], [\"customer_rank\", \">\", 0]]}')"
        },
        {
          "description": "Get count only (lightweight)",
          "call": "execute_method('res.partner', 'search', kwargs_json='{\"domain\": [[\"is_company\", \"=\", true]], \"count\": true}')"
        }
      ]
    },
    "search_count": {
      "signature": "Model.search_count(domain)",
      "description": "Count records matching domain without loading them",
      "parameters": {
        "domain": {"type": "list", "description": "Filter conditions"}
      },
      "returns": "Integer count of matching records",
      "performance": "Lighter than search() - only runs COUNT query, doesn't load record data",
      "use_case": "Pagination totals, dashboard metrics, conditional checks",
      "example": {
        "description": "Count open invoices",
        "call": "execute_method('account.move', 'search_count', kwargs_json='{\"domain\": [[\"state\", \"=\", \"posted\"], [\"payment_state\", \"!=\", \"paid\"]]}')"
      }
    },
    "search_read": {
      "signature": "Model.search_read(domain=None, fields=None, offset=0, limit=None, order=None, load='_classic_read')",
      "description": "Search and read in single database call - most efficient for filtered data retrieval",
      "parameters": {
        "domain": {"type": "list", "default": "[]", "description": "Filter conditions"},
        "fields": {"type": "list[str] | None", "default": "None", "description": "Fields to return (None = all)"},
        "offset": {"type": "int", "default": "0", "description": "Records to skip"},
        "limit": {"type": "int | None", "default": "None", "description": "Max records"},
        "order": {"type": "str | None", "default": "None", "description": "Sort order"},
        "load": {"type": "str | None", "default": "'_classic_read'", "description": "Many2one format: '_classic_read' for (id, name), None for raw ID"}
      },
      "returns": "List of dictionaries with field values",
      "performance": "Single query vs search() + read() = 2 queries. Always prefer search_read when you need field data.",
      "example": {
        "description": "Get customer names and emails",
        "call": "execute_method('res.partner', 'search_read', kwargs_json='{\"domain\": [[\"customer_rank\", \">\", 0]], \"fields\": [\"name\", \"email\"], \"limit\": 50}')"
      }
    },
    "read": {
      "signature": "records.read(fields=None, load='_classic_read')",
      "description": "Read field values from specific records by ID",
      "parameters": {
        "fields": {
          "type": "list[str] | None",
          "default": "None (all fields)",
          "description": "List of field names to retrieve. If None, returns all fields."
        },
        "load": {
          "type": "str | None",
          "default": "'_classic_read'",
          "description": "Controls Many2one field loading behavior",
          "values": {
            "_classic_read": "Many2one returns (id, display_name) tuple - default behavior",
            "null": "Many2one returns raw ID only - better performance when display names not needed"
          }
        }
      },
      "returns": "List of dictionaries mapping field names to values. 'id' field always included.",
      "relational_fields": {
        "many2one_default": "(id, display_name) tuple",
        "many2one_load_null": "integer ID only",
        "one2many": "list of IDs (regardless of load param)",
        "many2many": "list of IDs (regardless of load param)"
      },
      "exceptions": {
        "AccessError": "User lacks permission to read requested fields",
        "ValueError": "Requested non-existent field"
      },
      "decorator": "@api.readonly - cannot be overridden",
      "examples": [
        {
          "description": "Read specific fields with display names",
          "call": "execute_method('res.partner', 'read', args_json='[[1, 2, 3]]', kwargs_json='{\"fields\": [\"name\", \"partner_id\"]}')"
        },
        {
          "description": "Read with raw IDs for performance",
          "call": "execute_method('res.partner', 'read', args_json='[[1, 2, 3]]', kwargs_json='{\"fields\": [\"name\", \"partner_id\"], \"load\": null}')"
        }
      ],
      "performance_tips": [
        "Specify only required fields to reduce data transfer",
        "Use load=null when you don't need Many2one display names",
        "Batch-read multiple records in one call instead of looping"
      ]
    },
    "create": {
      "signature": "Model.create(vals_list)",
      "description": "Create new record(s) in the database",
      "parameters": {
        "vals_list": {
          "type": "dict | list[dict]",
          "description": "Single dict for one record, or list of dicts for batch creation"
        }
      },
      "returns": "Recordset containing the newly created record(s)",
      "v19_recommendation": "Always use batch creation (list of dicts) for better performance. Odoo 19 uses @api.model_create_multi internally.",
      "relational_field_commands": {
        "_note": "Commands for One2many and Many2many fields during create",
        "(0, 0, {values})": "Create and link a new related record",
        "(4, id, 0)": "Link an existing record by ID (Many2many only)",
        "(6, 0, [ids])": "Replace all links with the given list of IDs (Many2many)"
      },
      "exceptions": {
        "AccessError": "User lacks create permission on the model",
        "ValidationError": "Business rule validation failed (from @api.constrains)",
        "UserError": "Operation would create invalid state (e.g., circular hierarchy)"
      },
      "examples": [
        {
          "description": "Create single record",
          "call": "execute_method('res.partner', 'create', args_json='[{\"name\": \"John Doe\", \"email\": \"john@example.com\"}]')"
        },
        {
          "description": "Batch create multiple records (recommended)",
          "call": "execute_method('res.partner', 'create', args_json='[[{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]]')"
        },
        {
          "description": "Create with One2many lines",
          "call": "execute_method('sale.order', 'create', args_json='[{\"partner_id\": 1, \"order_line\": [[0, 0, {\"product_id\": 1, \"product_uom_qty\": 5}]]}]')"
        },
        {
          "description": "Create with Many2many tags",
          "call": "execute_method('res.partner', 'create', args_json='[{\"name\": \"Test\", \"category_id\": [[6, 0, [1, 2, 3]]]}]')"
        }
      ],
      "performance_tips": [
        "Use batch creation (list of dicts) instead of looping single creates",
        "Prepare all values before create() to minimize DB queries",
        "Use (6, 0, [ids]) for Many2many instead of multiple (4, id, 0) commands"
      ]
    },
    "write": {
      "signature": "records.write(vals)",
      "description": "Update existing record(s) with new values",
      "parameters": {
        "vals": {
          "type": "dict",
          "description": "Dictionary of field names to new values"
        }
      },
      "returns": "True on success",
      "note": "Operates on recordset - updates ALL records in self",
      "relational_field_commands": {
        "_note": "Commands for One2many and Many2many fields during write",
        "(0, 0, {values})": "Create and link a new related record",
        "(1, id, {values})": "Update an existing linked record",
        "(2, id, 0)": "Delete the linked record from database",
        "(3, id, 0)": "Unlink record without deleting (Many2many only)",
        "(4, id, 0)": "Link an existing record (Many2many only)",
        "(5, 0, 0)": "Unlink all records (Many2many only)",
        "(6, 0, [ids])": "Replace all links with given IDs (Many2many)"
      },
      "exceptions": {
        "AccessError": "User lacks write permission",
        "ValidationError": "Business rule validation failed",
        "MissingError": "Record was deleted during operation"
      },
      "examples": [
        {
          "description": "Update single field",
          "call": "execute_method('res.partner', 'write', args_json='[[1], {\"name\": \"New Name\"}]')"
        },
        {
          "description": "Update multiple records",
          "call": "execute_method('res.partner', 'write', args_json='[[1, 2, 3], {\"active\": false}]')"
        },
        {
          "description": "Add One2many line to existing record",
          "call": "execute_method('sale.order', 'write', args_json='[[1], {\"order_line\": [[0, 0, {\"product_id\": 5, \"product_uom_qty\": 2}]]}]')"
        },
        {
          "description": "Update existing One2many line",
          "call": "execute_method('sale.order', 'write', args_json='[[1], {\"order_line\": [[1, 10, {\"product_uom_qty\": 10}]]}]')"
        },
        {
          "description": "Replace all Many2many links",
          "call": "execute_method('res.partner', 'write', args_json='[[1], {\"category_id\": [[6, 0, [1, 2]]]}]')"
        }
      ]
    },
    "unlink": {
      "signature": "records.unlink()",
      "description": "Delete record(s) from the database",
      "parameters": {},
      "returns": "True on success",
      "note": "Operates on recordset - deletes ALL records in self. Cascades based on ondelete settings.",
      "exceptions": {
        "AccessError": "User lacks unlink permission",
        "UserError": "Deletion blocked by business rule (e.g., @api.ondelete)"
      },
      "examples": [
        {
          "description": "Delete records by ID",
          "call": "execute_method('res.partner', 'unlink', args_json='[[1, 2, 3]]')"
        }
      ],
      "warning": "Deletion is permanent. Records with ondelete='restrict' on related fields will block deletion."
    },
    "name_search": {
      "signature": "Model.name_search(name='', domain=None, operator='ilike', limit=100)",
      "description": "Search for records matching name pattern, used for Many2one autocomplete",
      "parameters": {
        "name": {"type": "str", "default": "''", "description": "Search string to match"},
        "domain": {"type": "list", "default": "None", "description": "Additional domain filter"},
        "operator": {"type": "str", "default": "'ilike'", "description": "Comparison operator (ilike, like, =, etc.)"},
        "limit": {"type": "int", "default": "100", "description": "Maximum results to return"}
      },
      "returns": "List of tuples: [(id, display_name), ...]",
      "use_case": "Finding records by partial name match, like autocomplete in forms",
      "example": {
        "description": "Search partners by name",
        "call": "execute_method('res.partner', 'name_search', kwargs_json='{\"name\": \"john\", \"limit\": 10}')"
      }
    },
    "default_get": {
      "signature": "Model.default_get(fields_list)",
      "description": "Get default values for specified fields when creating new records",
      "parameters": {
        "fields_list": {"type": "list[str]", "description": "List of field names to get defaults for"}
      },
      "returns": "Dictionary of {field_name: default_value}",
      "use_case": "Pre-populating form values, understanding what defaults will be applied",
      "example": {
        "description": "Get defaults for sale order",
        "call": "execute_method('sale.order', 'default_get', args_json='[[\"partner_id\", \"date_order\", \"company_id\"]]')"
      }
    },
    "fields_get": {
      "signature": "Model.fields_get(allfields=None, attributes=None)",
      "description": "Get field definitions and metadata for the model",
      "parameters": {
        "allfields": {"type": "list[str] | None", "default": "None", "description": "Specific fields to retrieve, or None for all"},
        "attributes": {"type": "list[str] | None", "default": "None", "description": "Specific attributes to include (string, type, required, readonly, etc.)"}
      },
      "returns": "Dictionary of {field_name: {attribute: value, ...}}",
      "use_case": "Schema introspection, dynamic form generation, field validation",
      "common_attributes": ["string", "type", "required", "readonly", "relation", "selection", "help"],
      "example": {
        "description": "Get all fields for res.partner",
        "call": "execute_method('res.partner', 'fields_get')"
      }
    },
    "copy": {
      "signature": "records.copy(default=None)",
      "description": "Duplicate a record with optional field overrides",
      "parameters": {
        "default": {"type": "dict | None", "default": "None", "description": "Field values to override in the copy"}
      },
      "returns": "New duplicated record",
      "note": "Fields with copy=False attribute are not copied. State fields typically reset to draft.",
      "example": {
        "description": "Duplicate a sale order with new date",
        "call": "execute_method('sale.order', 'copy', args_json='[[1]]', kwargs_json='{\"default\": {\"date_order\": \"2025-01-15\"}}')"
      }
    },
    "check_access_rights": {
      "signature": "Model.check_access_rights(operation, raise_exception=True)",
      "description": "Check if current user has permission for operation on model (legacy, still works)",
      "parameters": {
        "operation": {"type": "str", "description": "One of: 'read', 'write', 'create', 'unlink'"},
        "raise_exception": {"type": "bool", "default": "True", "description": "Raise AccessError or return False"}
      },
      "returns": "True if permitted, False or raises AccessError if not",
      "note": "Still works in v19 but has_access is preferred. Note: check_access (without _rights) is @api.private and NOT callable via RPC.",
      "example": {
        "description": "Check if user can create invoices",
        "call": "execute_method('account.move', 'check_access_rights', args_json='[\"create\"]')"
      }
    },
    "has_access": {
      "signature": "Model.has_access(operation)",
      "description": "Check if user has access for operation on model (v19+ preferred)",
      "parameters": {
        "operation": {"type": "str", "description": "One of: 'read', 'write', 'create', 'unlink'"}
      },
      "returns": "Boolean - True if user has access, False otherwise. Never raises an exception.",
      "note": "Preferred over check_access_rights in v19+. Simpler API: always returns boolean, never raises.",
      "example": {
        "description": "Check if user can read partners",
        "call": "execute_method('res.partner', 'has_access', args_json='[\"read\"]')"
      }
    },
    "browse": {
      "signature": "Model.browse(ids)",
      "description": "Return a recordset for the given IDs without fetching data from database",
      "parameters": {
        "ids": {"type": "int | list[int]", "description": "Single ID or list of IDs"}
      },
      "returns": "Recordset containing the specified records (may include deleted/non-existent)",
      "note": "Does NOT verify records exist - use exists() to filter. Useful for building recordsets from known IDs.",
      "example": {
        "description": "Browse specific partner IDs",
        "note": "Typically used internally; for API access use read() with IDs instead"
      }
    },
    "exists": {
      "signature": "records.exists()",
      "description": "Return subset of records that actually exist in database",
      "parameters": {},
      "returns": "Recordset with only existing records (filters out deleted/invalid IDs)",
      "use_case": "Validate records before operations, clean up stale recordsets",
      "example": {
        "description": "Filter out deleted records",
        "note": "Useful after browse() or when working with potentially stale IDs"
      }
    },
    "ensure_one": {
      "signature": "records.ensure_one()",
      "description": "Verify recordset contains exactly one record, raise error otherwise",
      "parameters": {},
      "returns": "self (the single-record recordset)",
      "exceptions": {
        "ValueError": "If recordset is empty or contains multiple records"
      },
      "use_case": "Validate single record before operations that expect exactly one"
    },
    "filtered": {
      "signature": "records.filtered(func)",
      "description": "Return records satisfying the filter function",
      "parameters": {
        "func": {"type": "callable | str", "description": "Function taking record returning bool, or field name (truthy filter)"}
      },
      "returns": "Recordset with matching records",
      "examples": [
        {"description": "Filter by lambda", "code": "partners.filtered(lambda p: p.is_company)"},
        {"description": "Filter by field name", "code": "partners.filtered('is_company')"}
      ],
      "note": "Not directly callable via API - used internally in Odoo code"
    },
    "filtered_domain": {
      "signature": "records.filtered_domain(domain)",
      "description": "Filter records using a domain expression (in-memory, no SQL)",
      "parameters": {
        "domain": {"type": "list", "description": "Standard Odoo domain filter"}
      },
      "returns": "Recordset with matching records",
      "use_case": "Apply domain filter to already-loaded recordset without new DB query",
      "note": "Faster than search when records are already in cache"
    },
    "mapped": {
      "signature": "records.mapped(func)",
      "description": "Apply function to all records and return results",
      "parameters": {
        "func": {"type": "callable | str", "description": "Function or field name (dot notation supported)"}
      },
      "returns": "List of results, or recordset if mapping to relational field",
      "examples": [
        {"description": "Get all names", "code": "partners.mapped('name')"},
        {"description": "Get related countries", "code": "partners.mapped('country_id')"},
        {"description": "Traverse relations", "code": "orders.mapped('partner_id.country_id.name')"}
      ],
      "note": "Since v13, relational field access works like mapped: records.partner_id == records.mapped('partner_id')"
    },
    "sorted": {
      "signature": "records.sorted(key=None, reverse=False)",
      "description": "Return recordset sorted by key function",
      "parameters": {
        "key": {"type": "callable | str | None", "description": "Sort key function or field name"},
        "reverse": {"type": "bool", "default": "False", "description": "Reverse sort order"}
      },
      "returns": "New sorted recordset",
      "examples": [
        {"description": "Sort by name", "code": "partners.sorted('name')"},
        {"description": "Sort by date descending", "code": "orders.sorted('date_order', reverse=True)"}
      ]
    },
    "grouped": {
      "signature": "records.grouped(key)",
      "description": "Group records by key, returning dict of recordsets",
      "parameters": {
        "key": {"type": "callable | str", "description": "Grouping function or field name"}
      },
      "returns": "Dictionary mapping keys to recordsets",
      "example": {
        "description": "Group orders by customer",
        "code": "orders.grouped('partner_id')"
      },
      "note": "New in Odoo 17+"
    },
    "with_context": {
      "signature": "records.with_context(*args, **kwargs)",
      "description": "Return recordset with modified context",
      "parameters": {
        "args": {"type": "dict", "description": "Context dict to merge (replaces if single arg)"},
        "kwargs": {"type": "any", "description": "Context key=value pairs to add"}
      },
      "returns": "New recordset with updated context",
      "use_cases": ["Set language for translations", "Pass flags to methods", "Set default values"],
      "example": {
        "description": "Set language context",
        "code": "partners.with_context(lang='fr_FR').read(['name'])"
      }
    },
    "with_user": {
      "signature": "records.with_user(user)",
      "description": "Return recordset with different user (for access rights)",
      "parameters": {
        "user": {"type": "int | res.users", "description": "User ID or record"}
      },
      "returns": "New recordset operating as specified user",
      "note": "Changes access rights context, not sudo"
    },
    "with_company": {
      "signature": "records.with_company(company)",
      "description": "Return recordset with different company context",
      "parameters": {
        "company": {"type": "int | res.company", "description": "Company ID or record"}
      },
      "returns": "New recordset in specified company context",
      "use_case": "Multi-company operations, cross-company data access"
    },
    "sudo": {
      "signature": "records.sudo(flag=True)",
      "description": "Return recordset bypassing access rights (superuser mode)",
      "parameters": {
        "flag": {"type": "bool", "default": "True", "description": "Enable/disable sudo mode"}
      },
      "returns": "New recordset in superuser mode",
      "warning": "Bypasses ALL security - use sparingly and carefully",
      "note": "Cannot be called via external API - internal use only"
    },
    "name_create": {
      "signature": "Model.name_create(name)",
      "description": "Create record with only a name value (quick create)",
      "parameters": {
        "name": {"type": "str", "description": "Display name for new record"}
      },
      "returns": "Tuple (id, display_name) of created record",
      "use_case": "Quick creation from autocomplete dropdowns",
      "example": {
        "description": "Quick create a partner",
        "call": "execute_method('res.partner', 'name_create', args_json='[\"New Partner\"]')"
      }
    },
    "search_fetch": {
      "signature": "Model.search_fetch(domain, field_names, offset=0, limit=None, order=None)",
      "description": "Search and prefetch fields in optimized way (new in v17) - @api.private, NOT callable via RPC",
      "parameters": {
        "domain": {"type": "list", "description": "Search domain"},
        "field_names": {"type": "list[str]", "description": "Fields to prefetch into cache"},
        "offset": {"type": "int", "default": "0"},
        "limit": {"type": "int | None", "default": "None"},
        "order": {"type": "str | None", "default": "None"}
      },
      "returns": "Recordset with specified fields pre-loaded in cache",
      "vs_search_read": "Returns recordset (not dicts), better for further ORM operations",
      "note": "@api.private in v19 - NOT callable via JSON-2 API. Use search_read instead for RPC access.",
      "rpc_callable": false
    },
    "fetch": {
      "signature": "records.fetch(field_names)",
      "description": "Prefetch specified fields for recordset (populate cache) - @api.private, NOT callable via RPC",
      "parameters": {
        "field_names": {"type": "list[str]", "description": "Fields to fetch into cache"}
      },
      "returns": "self (recordset unchanged, but cache populated)",
      "use_case": "Optimize batch operations by pre-loading needed fields",
      "note": "@api.private in v19 - NOT callable via JSON-2 API. Use read instead for RPC access.",
      "rpc_callable": false
    },
    "action_archive": {
      "signature": "records.action_archive()",
      "description": "Archive records (set active=False)",
      "parameters": {},
      "returns": "True",
      "note": "Only available on models with 'active' field",
      "example": {
        "description": "Archive partners",
        "call": "execute_method('res.partner', 'action_archive', args_json='[[1, 2, 3]]')"
      }
    },
    "action_unarchive": {
      "signature": "records.action_unarchive()",
      "description": "Unarchive records (set active=True)",
      "parameters": {},
      "returns": "True",
      "note": "Only available on models with 'active' field",
      "example": {
        "description": "Unarchive partners",
        "call": "execute_method('res.partner', 'action_unarchive', args_json='[[1, 2, 3]]')"
      }
    }
  },

  "model_types": {
    "_note": "Odoo 19 model types and their characteristics",
    "models.Model": {
      "description": "Regular persistent model with database table",
      "table_created": true,
      "auto_cleanup": false,
      "use_case": "Standard business data (partners, orders, invoices)"
    },
    "models.TransientModel": {
      "description": "Temporary model for wizard data, auto-cleaned after inactivity",
      "table_created": true,
      "auto_cleanup": true,
      "use_case": "Wizards, temporary processing, user input dialogs",
      "note": "Records deleted automatically by ir.autovacuum"
    },
    "models.AbstractModel": {
      "description": "Abstract model for shared behavior, no database table",
      "table_created": false,
      "auto_cleanup": false,
      "use_case": "Mixins, shared methods inherited by other models",
      "note": "Cannot be queried directly via API"
    }
  },

  "model_attributes": {
    "_note": "Common model attributes for schema understanding",
    "_name": "Unique technical identifier (e.g., 'sale.order')",
    "_description": "Human-readable model name for UI",
    "_order": "Default sort order (e.g., 'create_date desc, name')",
    "_rec_name": "Field used as display name in dropdowns (default: 'name')",
    "_inherit": "Model(s) to extend via classical inheritance",
    "_inherits": "Delegation inheritance - links to parent record",
    "_parent_name": "Field name for parent reference in hierarchy (default: 'parent_id')",
    "_parent_store": "Enable materialized path for fast hierarchy queries",
    "_sql_constraints": "Database-level unique/check constraints",
    "_log_access": "Auto-create create_uid, create_date, write_uid, write_date fields"
  },

  "field_types": {
    "_note": "Odoo 19 field type reference for schema interpretation",
    "simple": {
      "boolean": {"python": "bool", "json": "true/false", "default": "false"},
      "char": {"python": "str", "json": "string", "params": ["size"], "note": "size limits max length"},
      "text": {"python": "str", "json": "string", "note": "unlimited length, for large text"},
      "integer": {"python": "int", "json": "number", "default": "0", "note": "no null, defaults to 0"},
      "float": {"python": "float", "json": "number", "params": ["digits"], "note": "digits=(precision, scale)"},
      "date": {"python": "date", "json": "string YYYY-MM-DD", "helpers": ["context_today", "today", "from_string", "to_string"]},
      "datetime": {"python": "datetime", "json": "string YYYY-MM-DD HH:MM:SS", "helpers": ["now", "context_timestamp", "from_string", "to_string"]},
      "binary": {"python": "bytes", "json": "base64 string", "note": "for files, images, attachments"},
      "html": {"python": "str", "json": "string (HTML)", "note": "rich text with HTML formatting"},
      "monetary": {"python": "float", "json": "number", "params": ["currency_field", "digits"], "note": "REQUIRES currency_field pointing to res.currency"}
    },
    "selection": {
      "selection": {"python": "str", "json": "string (key)", "params": ["selection"], "note": "selection is list of (key, label) tuples or callable"},
      "reference": {"python": "str", "json": "string 'model,id'", "params": ["selection"], "note": "dynamic link to multiple models"}
    },
    "relational": {
      "many2one": {
        "python": "int (record ID)",
        "json_read": "(id, display_name) or id with load=null",
        "json_write": "integer ID",
        "params": ["comodel_name", "ondelete", "delegate"],
        "ondelete_options": ["restrict", "cascade", "set null"],
        "note": "ALWAYS pass integer ID when writing, never the name string"
      },
      "one2many": {
        "python": "recordset",
        "json_read": "[id, id, ...]",
        "json_write": "commands: (0,0,{vals}), (1,id,{vals}), (2,id,0), etc.",
        "params": ["comodel_name", "inverse_name"],
        "note": "inverse_name is the Many2one field on the related model"
      },
      "many2many": {
        "python": "recordset",
        "json_read": "[id, id, ...]",
        "json_write": "commands: (4,id,0) link, (3,id,0) unlink, (6,0,[ids]) replace",
        "params": ["comodel_name", "relation", "column1", "column2"],
        "note": "relation is the junction table name"
      }
    },
    "common_attributes": {
      "string": "Field label in UI",
      "required": "Cannot be empty (default: false)",
      "readonly": "Not user-editable (default: false)",
      "default": "Default value (literal or callable)",
      "help": "Tooltip text",
      "compute": "Method name for computed fields",
      "store": "Store computed field in DB (default: false for computed)",
      "related": "Shortcut for related field access",
      "translate": "Enable multi-language (default: false)",
      "index": "Create DB index (default: false)",
      "copy": "Include in record duplication (default: true)",
      "groups": "Limit field access to security groups"
    }
  },

  "method_decorators": {
    "_note": "Odoo 19 method decorators and their RPC accessibility",
    "rpc_accessible": {
      "@api.model": {
        "description": "Method works at model level, not on specific records",
        "rpc_callable": true,
        "example_use": "Utility methods, custom create logic, sequence generation",
        "note": "No 'self' records, use self.env to access data"
      },
      "@api.model_create_multi": {
        "description": "Optimized bulk record creation",
        "rpc_callable": true,
        "note": "Receives vals_list (list of dicts), returns recordset"
      },
      "@api.readonly": {
        "description": "Method executes in read-only mode",
        "rpc_callable": true,
        "note": "Cannot modify database, used for reporting/queries"
      }
    },
    "not_rpc_accessible": {
      "@api.private": {
        "description": "BLOCKED from external RPC access",
        "rpc_callable": false,
        "note": "MCP CANNOT call these methods - internal use only"
      }
    },
    "validation_decorators": {
      "@api.constrains(*fields)": {
        "description": "Validate data before saving",
        "triggered_by": "create/write on specified fields",
        "raises": "ValidationError if invalid"
      },
      "@api.ondelete(at_uninstall=False)": {
        "description": "Control deletion behavior",
        "note": "at_uninstall=True allows deletion during module uninstall"
      }
    },
    "computed_field_decorators": {
      "@api.depends(*fields)": {
        "description": "Recompute when dependent fields change",
        "note": "Required for stored computed fields"
      },
      "@api.depends_context(*keys)": {
        "description": "Recompute when context keys change",
        "note": "For company/language-dependent computations"
      }
    },
    "ui_only": {
      "@api.onchange(*fields)": {
        "description": "Real-time UI updates before save",
        "rpc_callable": false,
        "note": "NOT triggered by API calls - UI form changes only"
      }
    },
    "mcp_implications": {
      "callable_via_mcp": ["public methods", "@api.model", "@api.model_create_multi", "@api.readonly"],
      "not_callable": ["@api.private methods", "@api.onchange (UI-only)"],
      "tip": "If execute_method returns 'method not found' or access error, the method may be @api.private"
    }
  },

  "module_documentation": {
    "_note": "Maps module names to documentation and GitHub paths for Odoo 19.0",
    "ai": {"docs": "/applications/productivity/ai", "github": null, "note": "Enterprise only"},
    "sale": {"docs": "/applications/sales/sales", "github": "/sale/models/"},
    "purchase": {"docs": "/applications/inventory_and_mrp/purchase", "github": "/purchase/models/"},
    "stock": {"docs": "/applications/inventory_and_mrp/inventory", "github": "/stock/models/"},
    "account": {"docs": "/applications/finance/accounting", "github": "/account/models/"},
    "crm": {"docs": "/applications/sales/crm", "github": "/crm/models/"},
    "project": {"docs": "/applications/services/project", "github": "/project/models/"},
    "hr": {"docs": "/applications/hr/employees", "github": "/hr/models/"},
    "website": {"docs": "/applications/websites/website", "github": "/website/views/", "snippets": "/website/views/snippets"},
    "website_sale": {"docs": "/applications/websites/ecommerce", "github": "/website_sale/models/"},
    "mrp": {"docs": "/applications/inventory_and_mrp/manufacturing", "github": "/mrp/models/"},
    "product": {"docs": "/applications/inventory_and_mrp/inventory/products", "github": "/product/models/"},
    "helpdesk": {"docs": "/applications/services/helpdesk", "github": "/helpdesk/models/"},
    "event": {"docs": "/applications/marketing/events", "github": "/event/models/"},
    "knowledge": {"docs": "/applications/productivity/knowledge", "github": "/knowledge/models/"},
    "mail": {"docs": "/applications/productivity/discuss", "github": "/mail/models/"},
    "discuss": {"docs": "/applications/productivity/discuss", "github": "/mail/models/"},
    "base": {"docs": null, "github": "/base/models/"}
  },

  "model_to_module": {
    "_note": "Maps model names to their parent module",
    "ai.agent": "ai",
    "ai.topic": "ai",
    "ai.agent.source": "ai",
    "ai.embedding": "ai",
    "ai.composer": "ai",
    "ai.prompt.button": "ai",
    "sale.order": "sale",
    "sale.order.line": "sale",
    "purchase.order": "purchase",
    "purchase.order.line": "purchase",
    "stock.picking": "stock",
    "stock.move": "stock",
    "stock.move.line": "stock",
    "stock.quant": "stock",
    "stock.warehouse": "stock",
    "stock.location": "stock",
    "account.move": "account",
    "account.move.line": "account",
    "account.payment": "account",
    "account.account": "account",
    "account.journal": "account",
    "crm.lead": "crm",
    "crm.stage": "crm",
    "crm.team": "crm",
    "project.project": "project",
    "project.task": "project",
    "hr.employee": "hr",
    "hr.department": "hr",
    "hr.contract": "hr",
    "product.template": "product",
    "product.product": "product",
    "product.category": "product",
    "product.pricelist": "product",
    "website.page": "website",
    "website.menu": "website",
    "res.partner": "base",
    "res.users": "base",
    "res.company": "base",
    "res.country": "base",
    "ir.ui.view": "base",
    "ir.model": "base",
    "knowledge.article": "knowledge",
    "discuss.channel": "mail",
    "discuss.channel.member": "mail",
    "mail.message": "mail",
    "mail.followers": "mail",
    "mail.activity": "mail"
  },

  "api_patterns": {
    "_note": "Common API patterns for Odoo v2 JSON-2 API",
    "domain_operators": {
      "comparison": ["=", "!=", ">", ">=", "<", "<="],
      "list": ["in", "not in"],
      "text": ["like", "ilike", "=like", "=ilike"],
      "logic": ["&", "|", "!"]
    },
    "relational_commands": {
      "_note": "Commands for One2many and Many2many fields (Command class in odoo.fields)",
      "CREATE": {
        "tuple": [0, 0, {"values": "..."}],
        "description": "Create a new record and link it",
        "applies_to": ["One2many", "Many2many"]
      },
      "UPDATE": {
        "tuple": [1, "id", {"values": "..."}],
        "description": "Update an existing linked record",
        "applies_to": ["One2many"]
      },
      "DELETE": {
        "tuple": [2, "id", 0],
        "description": "Remove record from database (unlink + delete)",
        "applies_to": ["One2many"]
      },
      "UNLINK": {
        "tuple": [3, "id", 0],
        "description": "Remove link without deleting record",
        "applies_to": ["Many2many"]
      },
      "LINK": {
        "tuple": [4, "id", 0],
        "description": "Link an existing record",
        "applies_to": ["Many2many"]
      },
      "CLEAR": {
        "tuple": [5, 0, 0],
        "description": "Remove all links (does not delete records)",
        "applies_to": ["Many2many"]
      },
      "SET": {
        "tuple": [6, 0, ["ids"]],
        "description": "Replace all links with given IDs",
        "applies_to": ["Many2many"]
      }
    },
    "one2many_commands": {
      "_note": "Legacy format reference - use relational_commands above",
      "0": {"syntax": "(0, 0, {values})", "description": "Create new linked record"},
      "1": {"syntax": "(1, id, {values})", "description": "Update existing record"},
      "2": {"syntax": "(2, id, 0)", "description": "Delete record"},
      "3": {"syntax": "(3, id, 0)", "description": "Unlink without delete (M2M only)"},
      "4": {"syntax": "(4, id, 0)", "description": "Link existing record (M2M only)"},
      "5": {"syntax": "(5, 0, 0)", "description": "Unlink all (M2M only)"},
      "6": {"syntax": "(6, 0, [ids])", "description": "Replace all with list (M2M only)"}
    },
    "field_types": {
      "Many2one": "Always use numeric ID, never string name",
      "One2many": "Use command tuples: (0,0,{}), (1,id,{}), (2,id,0)",
      "Many2many": "Use command tuples: (4,id,0), (6,0,[ids])",
      "Date": "String format: YYYY-MM-DD",
      "Datetime": "String format: YYYY-MM-DD HH:MM:SS",
      "Selection": "Use the key string, not the label"
    },
    "message_types": {
      "_note": "mail.message.message_type - REQUIRED field for creating messages",
      "comment": "User comment (chatter, discuss) - USE THIS FOR POSTING MESSAGES",
      "email": "Incoming email (mailgateway)",
      "email_outgoing": "Outgoing email (mailing)",
      "notification": "System notification (tracking)",
      "auto_comment": "Automated notification (acknowledgment)",
      "user_notification": "Notification for specific recipient"
    }
  },

  "modules": {
    "knowledge": {
      "model": "knowledge.article",
      "special_methods": {
        "article_create": {
          "instead_of": "create",
          "params": {"title": "string", "body": "html", "parent_id": "integer|false"},
          "description": "Create a new knowledge article"
        },
        "article_duplicate": {
          "params": {},
          "description": "Duplicate an existing article"
        }
      },
      "field_mappings": {
        "name": "title"
      },
      "notes": "Do NOT use create() directly - use article_create(title=...)"
    },

    "sale": {
      "model": "sale.order",
      "special_methods": {
        "action_confirm": {
          "params": {},
          "description": "Confirm quotation to sales order",
          "requires_ids": true
        },
        "action_cancel": {
          "params": {},
          "description": "Cancel the sales order",
          "requires_ids": true
        },
        "action_draft": {
          "params": {},
          "description": "Reset to draft state",
          "requires_ids": true
        },
        "action_quotation_send": {
          "params": {},
          "description": "Open wizard to send quotation by email"
        },
        "action_quotation_sent": {
          "params": {},
          "description": "Mark quotation as sent",
          "requires_ids": true
        },
        "action_lock": {
          "params": {},
          "description": "Lock the sales order (prevent modifications)",
          "requires_ids": true
        },
        "action_unlock": {
          "params": {},
          "description": "Unlock the sales order",
          "requires_ids": true
        },
        "action_preview_sale_order": {
          "params": {},
          "description": "Open portal preview of the order"
        },
        "action_update_taxes": {
          "params": {},
          "description": "Recompute taxes on order lines"
        },
        "action_update_prices": {
          "params": {},
          "description": "Update prices based on current pricelist"
        },
        "action_view_invoice": {
          "params": {"invoices": "recordset|false"},
          "description": "Open linked invoices view"
        },
        "_create_invoices": {
          "params": {"grouped": "boolean", "final": "boolean", "date": "date|null"},
          "description": "Create invoices from confirmed orders"
        }
      },
      "workflows": {
        "quotation_to_invoice": ["action_confirm", "_create_invoices"]
      }
    },

    "account": {
      "model": "account.move",
      "special_methods": {
        "action_post": {
          "params": {},
          "description": "Post/validate the invoice or journal entry",
          "requires_ids": true
        },
        "button_draft": {
          "params": {},
          "description": "Reset posted entry to draft",
          "requires_ids": true
        },
        "button_cancel": {
          "params": {},
          "description": "Cancel the entry",
          "requires_ids": true
        },
        "button_set_checked": {
          "params": {},
          "description": "Mark entry as checked/reviewed",
          "requires_ids": true
        },
        "action_register_payment": {
          "params": {},
          "description": "Open payment registration wizard"
        },
        "action_force_register_payment": {
          "params": {},
          "description": "Force register payment (bypass checks)"
        },
        "action_reverse": {
          "params": {},
          "description": "Create reversal/credit note entry"
        },
        "action_duplicate": {
          "params": {},
          "description": "Duplicate the invoice"
        },
        "action_send_and_print": {
          "params": {},
          "description": "Send invoice by email and/or print"
        },
        "action_invoice_sent": {
          "params": {},
          "description": "Mark invoice as sent",
          "requires_ids": true
        },
        "action_switch_move_type": {
          "params": {},
          "description": "Switch between invoice types (customer/vendor)"
        },
        "action_view_invoice": {
          "params": {"invoices": "recordset|false"},
          "description": "Open invoice view"
        }
      },
      "move_types": {
        "out_invoice": "Customer Invoice",
        "in_invoice": "Vendor Bill",
        "out_refund": "Customer Credit Note",
        "in_refund": "Vendor Refund",
        "entry": "Journal Entry",
        "out_receipt": "Sales Receipt",
        "in_receipt": "Purchase Receipt"
      },
      "notes": "move_type determines invoice direction. state: draft, posted, cancel"
    },

    "crm": {
      "model": "crm.lead",
      "special_methods": {
        "action_set_won": {
          "params": {},
          "description": "Mark opportunity as won",
          "requires_ids": true
        },
        "action_set_won_rainbowman": {
          "params": {},
          "description": "Mark as won with celebration animation",
          "requires_ids": true
        },
        "action_set_lost": {
          "params": {"lost_reason_id": "integer", "lost_feedback": "string"},
          "description": "Mark opportunity as lost"
        },
        "action_set_automated_probability": {
          "params": {},
          "description": "Reset to AI-calculated probability"
        },
        "convert_opportunity": {
          "params": {"partner_id": "integer", "user_ids": "list|false", "team_id": "integer|false"},
          "description": "Convert lead to opportunity"
        },
        "action_schedule_meeting": {
          "params": {"smart_calendar": "boolean"},
          "description": "Open meeting scheduler"
        },
        "action_reschedule_meeting": {
          "params": {},
          "description": "Reschedule existing meeting"
        },
        "action_show_potential_duplicates": {
          "params": {},
          "description": "Show potential duplicate leads"
        },
        "action_unarchive": {
          "params": {},
          "description": "Restore archived lead"
        },
        "action_restore": {
          "params": {},
          "description": "Restore from lost state"
        }
      },
      "lead_vs_opportunity": {
        "type_lead": "Lead - unqualified prospect",
        "type_opportunity": "Opportunity - qualified sales opportunity"
      }
    },

    "stock": {
      "model": "stock.picking",
      "special_methods": {
        "button_validate": {
          "params": {},
          "description": "Validate the transfer",
          "requires_ids": true
        },
        "action_confirm": {
          "params": {},
          "description": "Confirm the picking",
          "requires_ids": true
        },
        "action_assign": {
          "params": {},
          "description": "Check availability / reserve stock",
          "requires_ids": true
        },
        "action_cancel": {
          "params": {},
          "description": "Cancel the picking"
        },
        "action_detailed_operations": {
          "params": {},
          "description": "Open detailed operations wizard"
        },
        "action_split_transfer": {
          "params": {},
          "description": "Split transfer into multiple pickings"
        },
        "action_toggle_is_locked": {
          "params": {},
          "description": "Lock/unlock the picking"
        },
        "action_put_in_pack": {
          "params": {"package_id": "integer|false", "package_type_id": "integer|false", "package_name": "string|false"},
          "description": "Put selected items into a package"
        },
        "button_scrap": {
          "params": {},
          "description": "Open scrap wizard for the picking"
        },
        "action_see_move_scrap": {
          "params": {},
          "description": "View scrap moves for this picking"
        },
        "action_see_packages": {
          "params": {},
          "description": "View packages in this picking"
        },
        "action_see_returns": {
          "params": {},
          "description": "View return pickings"
        },
        "action_view_reception_report": {
          "params": {},
          "description": "View reception report"
        }
      }
    },

    "purchase": {
      "model": "purchase.order",
      "special_methods": {
        "button_confirm": {
          "params": {},
          "description": "Confirm purchase order",
          "requires_ids": true
        },
        "button_approve": {
          "params": {"force": "boolean"},
          "description": "Approve purchase order (with optional force)",
          "requires_ids": true
        },
        "button_cancel": {
          "params": {},
          "description": "Cancel purchase order"
        },
        "button_draft": {
          "params": {},
          "description": "Reset to draft"
        },
        "button_lock": {
          "params": {},
          "description": "Lock the purchase order"
        },
        "button_unlock": {
          "params": {},
          "description": "Unlock the purchase order"
        },
        "action_rfq_send": {
          "params": {},
          "description": "Send RFQ to vendor by email"
        },
        "action_acknowledge": {
          "params": {},
          "description": "Acknowledge receipt of RFQ"
        },
        "action_create_invoice": {
          "params": {"attachment_ids": "list|false"},
          "description": "Create vendor bill from PO"
        },
        "action_view_invoice": {
          "params": {"invoices": "recordset|false"},
          "description": "View linked vendor bills"
        },
        "action_merge": {
          "params": {},
          "description": "Merge selected purchase orders"
        }
      }
    },

    "hr_expense": {
      "model": "hr.expense",
      "special_methods": {
        "action_submit_expenses": {
          "params": {},
          "description": "Submit expense for approval"
        },
        "action_approve_expense_sheets": {
          "params": {},
          "description": "Approve expense report"
        },
        "action_refuse_expense": {
          "params": {"reason": "string"},
          "description": "Refuse expense with reason"
        }
      }
    },

    "hr_leave": {
      "model": "hr.leave",
      "special_methods": {
        "action_approve": {
          "params": {},
          "description": "Approve leave request",
          "requires_ids": true
        },
        "action_refuse": {
          "params": {},
          "description": "Refuse leave request"
        },
        "action_confirm": {
          "params": {},
          "description": "Confirm leave request (employee)"
        }
      }
    },

    "project": {
      "model": "project.task",
      "special_methods": {
        "action_assign_to_me": {
          "params": {},
          "description": "Assign task to current user"
        },
        "action_open_parent_task": {
          "params": {},
          "description": "Navigate to parent task"
        }
      }
    },

    "documents": {
      "model": "documents.document",
      "special_methods": {
        "document_create": {
          "instead_of": "create",
          "params": {"name": "string", "folder_id": "integer", "datas": "base64"},
          "description": "Create a new document"
        }
      },
      "notes": "Some document operations require specific folder permissions"
    },

    "discuss": {
      "model": "discuss.channel",
      "special_methods": {
        "channel_create": {
          "params": {"name": "string", "group_id": "integer|false"},
          "description": "Create a new channel"
        },
        "add_members": {
          "params": {"partner_ids": "list[integer]"},
          "description": "Add members to channel",
          "requires_ids": true
        }
      },
      "notes": "Use create() with kwargs_json={'vals_list': [{...}]}. For posting messages, create mail.message directly instead of message_post (which fails via JSON-2 API)."
    },

    "ai": {
      "_note": "Odoo 19 Enterprise AI module - Agents, Topics, RAG Sources",
      "models": {
        "ai.agent": {
          "description": "AI Agent configuration with LLM model, topics, and knowledge sources",
          "key_fields": {
            "name": "Agent name",
            "subtitle": "Short description",
            "system_prompt": "System instructions for the agent",
            "llm_model": "LLM model selection (gpt-4o, gemini-2.5-flash, etc.)",
            "response_style": "analytical | balanced | creative",
            "restrict_to_sources": "Limit responses to RAG sources only",
            "topic_ids": "Many2many to ai.topic",
            "sources_ids": "One2many to ai.agent.source",
            "partner_id": "Avatar partner for the agent",
            "is_system_agent": "System agent (cannot be deleted)"
          }
        },
        "ai.topic": {
          "description": "Topic containing instructions and AI tools",
          "key_fields": {
            "name": "Topic title",
            "description": "Short description",
            "instructions": "Detailed instructions for the agent",
            "tool_ids": "Many2many to ir.actions.server (use_in_ai=True)"
          }
        },
        "ai.agent.source": {
          "description": "Knowledge source for RAG (URLs or files)",
          "key_fields": {
            "name": "Source name",
            "type": "url | binary",
            "status": "processing | indexed | failed",
            "url": "URL (if type=url)",
            "attachment_id": "Attachment (if type=binary)",
            "agent_id": "Parent agent",
            "is_active": "Active toggle"
          }
        },
        "ai.embedding": {
          "description": "Embedding chunks for semantic search",
          "key_fields": {
            "attachment_id": "Source attachment",
            "sequence": "Chunk order",
            "content": "Text content",
            "embedding_model": "Model used (text-embedding-3-small)",
            "embedding_vector": "Vector(1536) - pgvector type"
          }
        },
        "ai.composer": {
          "description": "AI composer interface (transient)",
          "note": "Wizard for AI interactions in forms"
        },
        "ai.prompt.button": {
          "description": "Quick action buttons in AI chat",
          "key_fields": {
            "name": "Button label",
            "prompt": "Prompt to send",
            "agent_id": "Parent agent"
          }
        }
      },
      "special_methods": {
        "get_direct_response": {
          "model": "ai.agent",
          "params": {"prompt": "string", "context_message": "string", "enable_html_response": "boolean"},
          "description": "Generate AI response directly without chat",
          "requires_ids": true
        },
        "open_agent_chat": {
          "model": "ai.agent",
          "params": {},
          "description": "Open chat window with the agent",
          "requires_ids": true
        },
        "create_from_attachments": {
          "model": "ai.agent.source",
          "params": {"attachment_ids": "list[integer]", "agent_id": "integer"},
          "description": "Create sources from existing attachments"
        },
        "create_from_binary_files": {
          "model": "ai.agent.source",
          "params": {"files_datas": "list[base64]", "agent_id": "integer"},
          "description": "Create sources from uploaded binary files"
        },
        "create_from_urls": {
          "model": "ai.agent.source",
          "params": {"urls": "list[string]", "agent_id": "integer"},
          "description": "Create sources from URLs (will be scraped)"
        }
      },
      "llm_models": {
        "openai": {
          "gpt-3.5-turbo": "GPT-3.5 Turbo",
          "gpt-4": "GPT-4",
          "gpt-4o": "GPT-4o (default)",
          "gpt-4.1": "GPT-4.1",
          "gpt-4.1-mini": "GPT-4.1 Mini",
          "gpt-5": "GPT-5",
          "gpt-5-mini": "GPT-5 Mini"
        },
        "google": {
          "gemini-2.5-pro": "Gemini 2.5 Pro",
          "gemini-2.5-flash": "Gemini 2.5 Flash",
          "gemini-1.5-pro": "Gemini 1.5 Pro (deprecated)",
          "gemini-1.5-flash": "Gemini 1.5 Flash (deprecated)"
        },
        "embedding_models": {
          "openai": "text-embedding-3-small (1536 dims)",
          "google": "gemini-embedding-001"
        }
      },
      "response_styles": {
        "analytical": {"temperature": 0.2, "description": "Precise, factual, consistent"},
        "balanced": {"temperature": 0.5, "description": "Mix of accuracy and creativity"},
        "creative": {"temperature": 0.8, "description": "Varied, human-like responses"}
      },
      "ai_tools": {
        "_note": "AI tools are ir.actions.server with use_in_ai=True",
        "default_tools": [
          "AI: Get Menu Details",
          "AI: Get Fields",
          "AI: Open Menu List/Kanban/Pivot/Graph",
          "AI: Compute Report Measures",
          "AI: Adjust Search",
          "AI: Search",
          "AI: Read group"
        ],
        "creating_custom_tools": {
          "model": "ir.actions.server",
          "required_fields": {
            "state": "code (Execute Code) or ai (AI)",
            "use_in_ai": true,
            "ai_tool_description": "Description for AI to understand the tool",
            "ai_tool_schema": "JSON schema defining parameters"
          },
          "example": {
            "name": "AI: Update Task Description",
            "state": "code",
            "use_in_ai": true,
            "code": "record.write({'description': content})",
            "ai_tool_schema": [{"name": "content", "type": "string", "description": "New description"}]
          }
        }
      },
      "default_topics": {
        "natural_language_search": {
          "description": "Interpret queries and open appropriate views",
          "tools": ["Get Menu Details", "Get Fields", "Open Menu *", "Adjust Search"]
        },
        "information_retrieval": {
          "description": "Search and aggregate data",
          "tools": ["Get Fields", "Search", "Read group"]
        },
        "create_leads": {
          "description": "Automated lead creation (requires CRM)",
          "module_dependency": "crm"
        }
      },
      "rag_workflow": {
        "1_create_source": "Create ai.agent.source (url or binary)",
        "2_process": "Cron: ir_cron_process_sources scrapes URLs",
        "3_embed": "Cron: ir_cron_generate_embedding creates chunks + vectors",
        "4_indexed": "Status changes to 'indexed', is_active=True",
        "5_search": "Semantic search via pgvector cosine similarity"
      },
      "api_config": {
        "openai_key": "ir.config_parameter: ai.openai_key or env ODOO_AI_CHATGPT_TOKEN",
        "google_key": "ir.config_parameter: ai.google_key or env ODOO_AI_GEMINI_TOKEN"
      },
      "notes": [
        "AI module is Enterprise only",
        "Requires pgvector PostgreSQL extension for embeddings",
        "Default Ask AI agent cannot modify database - add Topics with tools to enable actions",
        "Private methods (_generate_response, _ai_tool_*) not accessible via JSON-2 API"
      ]
    },

    "mail": {
      "model": "mail.message",
      "special_methods": {},
      "required_fields": ["message_type"],
      "field_values": {
        "message_type": {
          "_note": "REQUIRED field - categorizes how the message was generated",
          "email": "Incoming Email (via mailgateway)",
          "comment": "Comment (user input via discuss/composer) - USE THIS FOR CHATTER",
          "email_outgoing": "Outgoing Email (via mailing)",
          "notification": "System notification (tracking messages)",
          "auto_comment": "Automated notification (acknowledgment)",
          "user_notification": "Generated for a specific recipient"
        },
        "subtype_id": {
          "_note": "Controls visibility and notification behavior",
          "1": "Discussions (mail.mt_comment) - visible to followers",
          "2": "Note (mail.mt_note) - internal note, less visible"
        }
      },
      "create_example": {
        "chatter_comment": {
          "model": "res.partner",
          "res_id": 123,
          "body": "<p>Hello!</p>",
          "message_type": "comment",
          "subtype_id": 1
        },
        "internal_note": {
          "model": "sale.order",
          "res_id": 456,
          "body": "<p>Internal note</p>",
          "message_type": "comment",
          "subtype_id": 2
        }
      },
      "notes": "message_post() does not work via JSON-2 API. Create mail.message directly. REQUIRED: message_type field. Use 'comment' for user messages, 'notification' for system messages."
    }
  },

  "error_patterns": {
    "422": {
      "patterns": [
        {
          "match": "article_create",
          "suggestion": "Use article_create(title='...') instead of create() for knowledge.article"
        },
        {
          "match": "Missing required fields",
          "suggestion": "Check odoo://model/{model}/schema for required fields"
        },
        {
          "match": "Access Denied",
          "suggestion": "Check user permissions with has_access('read') on {model}"
        },
        {
          "match": "Expected singleton",
          "suggestion": "The method expects exactly one record but got multiple. Pass a single ID: args_json='[[id]]' not args_json='[[id1, id2]]'"
        },
        {
          "match": "null value in column",
          "suggestion": "A required field is missing. Read odoo://model/{model}/quick-schema to see required fields (req=true)"
        },
        {
          "match": "invalid field",
          "suggestion": "Field name doesn't exist on {model}. Read odoo://model/{model}/quick-schema to get exact field names"
        },
        {
          "match": "readonly",
          "suggestion": "Trying to write a readonly/computed field on {model}. Read odoo://model/{model}/quick-schema (ro=true = readonly)"
        },
        {
          "match": "Invalid value for Many2one",
          "suggestion": "Many2one fields require a numeric ID, not a string name. Use name_search to find the ID first, or use resolve_json parameter"
        },
        {
          "match": "expected an integer",
          "suggestion": "Many2one field requires numeric ID. Use name_search on the target model to resolve the name to an ID, or use resolve_json parameter"
        },
        {
          "match": "is not a valid value",
          "suggestion": "Invalid selection value for {model}. Read odoo://model/{model}/quick-schema to see valid selection values for the state field"
        },
        {
          "match": "does not exist",
          "suggestion": "Record not found. Verify the ID exists with search_read on {model} before calling this method"
        },
        {
          "match": "unique constraint",
          "suggestion": "Duplicate value violates a unique constraint on {model}. Check for existing records with the same value first"
        },
        {
          "match": "ondelete",
          "suggestion": "Cannot delete: other records reference this one. Check related records before deleting from {model}"
        },
        {
          "match": "vals_list",
          "suggestion": "create() expects a dict or list of dicts. Use args_json='[{\"field\": \"value\"}]' (single) or args_json='[[{\"f1\": \"v1\"}, {\"f2\": \"v2\"}]]' (batch)"
        }
      ]
    },
    "500": {
      "patterns": [
        {
          "match": "OperationalError",
          "suggestion": "Database error on {model}. Possible timeout or lock. Try reducing limit or simplifying domain"
        },
        {
          "match": "NoneType",
          "suggestion": "Null reference error on {model}. A computed field may depend on missing data. Try excluding computed fields from the fields list"
        },
        {
          "match": "NotImplementedError",
          "suggestion": "Method not fully implemented for this case on {model}. Check odoo://model-limitations for known issues"
        },
        {
          "match": "RecursionError",
          "suggestion": "Circular reference detected on {model}. Check for circular parent/child relationships"
        },
        {
          "match": "statement timeout",
          "suggestion": "Query too slow on {model}. Reduce limit, simplify domain, or avoid dot notation in filters"
        }
      ],
      "suggestion": "Internal server error on {model}. Check odoo://model-limitations for known issues, or try with simpler parameters."
    },
    "403": {
      "patterns": [
        {
          "match": "ir.rule",
          "suggestion": "Record-level security rule blocking access to {model}. The current user's ir.rule prevents this operation"
        },
        {
          "match": "group_",
          "suggestion": "User lacks the required security group for this operation on {model}. Check user groups in Odoo settings"
        }
      ],
      "suggestion": "Permission denied on {model}. Verify API key permissions and record-level access rules (ir.rule)."
    },
    "404": {
      "patterns": [
        {
          "match": "json/2",
          "suggestion": "API endpoint not found. Verify the model name '{model}' is correct (use odoo://find-model to search)"
        },
        {
          "match": "doc-bearer",
          "suggestion": "Live documentation unavailable. The api_doc module may not be installed, or the user lacks the group_allow_doc group"
        }
      ],
      "suggestion": "Not found. Verify the model name and record ID exist on {model}. Use odoo://find-model to search by concept."
    },
    "_fallback_patterns": {
      "_note": "Generic patterns matched against any error message regardless of HTTP status code",
      "patterns": [
        {
          "match": "Many2one",
          "suggestion": "Many2one fields require a numeric ID (integer), not a string name. Use name_search() or resolve_json to convert names to IDs"
        },
        {
          "match": "singleton",
          "suggestion": "Method expects exactly one record. Pass a single ID in the list: args_json='[[42]]'"
        },
        {
          "match": "readonly field",
          "suggestion": "Cannot write to a readonly/computed field on {model}. Exclude it from write values"
        }
      ]
    }
  }
}
